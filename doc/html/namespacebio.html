<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deep Sequencing Analysis: bio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Deep Sequencing Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bio Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_aa.html">Aa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_aas.html">Aas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_alignment.html">Alignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_alignment_template.html">AlignmentTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_bad_template_database_parse.html">BadTemplateDatabaseParse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_cdn.html">Cdn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_cdns.html">Cdns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_cell.html">Cell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_choice.html">Choice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_const_mapping.html">ConstMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_counter.html">Counter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_excessive_trimming_error.html">ExcessiveTrimmingError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_extracted_u_m_i.html">ExtractedUMI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_group_alignment.html">GroupAlignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_mapping_exception.html">MappingException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_mutation_count.html">MutationCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_nt.html">Nt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_nts.html">Nts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_orf.html">Orf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_overlap.html">Overlap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_polymer.html">Polymer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_polymer_base.html">PolymerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_read.html">Read</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_read_pair.html">ReadPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_template_database.html">TemplateDatabase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio_1_1_template_database_entry.html">TemplateDatabaseEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_translation_table.html">TranslationTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a189d4bb966edec501c1d8980e4680ce8"><td class="memItemLeft" align="right" valign="top"><a id="a189d4bb966edec501c1d8980e4680ce8"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Qual</b></td></tr>
<tr class="separator:a189d4bb966edec501c1d8980e4680ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7b3e677b9050b6500861c0c9a73017"><td class="memTemplParams" colspan="2"><a id="a8c7b3e677b9050b6500861c0c9a73017"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c7b3e677b9050b6500861c0c9a73017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vecvec</b> = std::vector&lt; std::vector&lt; T &gt; &gt;</td></tr>
<tr class="separator:a8c7b3e677b9050b6500861c0c9a73017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa4b9619f0755538ec0031e3d782084dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#aa4b9619f0755538ec0031e3d782084dc">MappingStage</a> { <b>Open</b>, 
<b>Stat</b>, 
<b>Map</b>
 }</td></tr>
<tr class="separator:aa4b9619f0755538ec0031e3d782084dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d7255272f91a2a5a72e8ab6742e4e1"><td class="memItemLeft" align="right" valign="top"><a id="a61d7255272f91a2a5a72e8ab6742e4e1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AlignmentMethod</b> { <b>ByCdns</b>, 
<b>ByAas</b>
 }</td></tr>
<tr class="separator:a61d7255272f91a2a5a72e8ab6742e4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad75cb9c72ce22dde815cebff63427e3f"><td class="memItemLeft" align="right" valign="top"><a id="ad75cb9c72ce22dde815cebff63427e3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mm256_translate_cdns</b> (char *dst, const char *src, size_t n, const <a class="el" href="classbio_1_1_aa.html">Aa</a> *ttable)</td></tr>
<tr class="separator:ad75cb9c72ce22dde815cebff63427e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7186f0f001510498800c63848731e3"><td class="memItemLeft" align="right" valign="top"><a id="acf7186f0f001510498800c63848731e3"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (const std::string &amp;str, const std::string &amp;delim)</td></tr>
<tr class="separator:acf7186f0f001510498800c63848731e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320a1508e48d50d15a6e7777014fdfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbio_1_1_overlap.html">Overlap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a6320a1508e48d50d15a6e7777014fdfa">find_overlapv_256</a> (const char *a, const size_t a_size, const char *b, const size_t b_size, size_t max_mismatches)</td></tr>
<tr class="separator:a6320a1508e48d50d15a6e7777014fdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0d9930fe8f393ec5fc7e6420c06afa"><td class="memItemLeft" align="right" valign="top"><a id="adf0d9930fe8f393ec5fc7e6420c06afa"></a>
<a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_cdnsubs</b> ()</td></tr>
<tr class="separator:adf0d9930fe8f393ec5fc7e6420c06afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fbb3af7886f1eaafce331cc9303e8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a80fbb3af7886f1eaafce331cc9303e8a">nw_align_aas</a> (const <a class="el" href="classbio_1_1_aas.html">Aas</a> &amp;q, const <a class="el" href="classbio_1_1_aas.html">Aas</a> &amp;t, const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;match, int32_t gapp, <a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;result)</td></tr>
<tr class="separator:a80fbb3af7886f1eaafce331cc9303e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5fd66bcb5118522e4f23f2e400daa"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#ab3b5fd66bcb5118522e4f23f2e400daa">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structbio_1_1_read.html">Read</a> &amp;rd)</td></tr>
<tr class="separator:ab3b5fd66bcb5118522e4f23f2e400daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e9ab7886c21561de71592ad122766"><td class="memTemplParams" colspan="2"><a id="a839e9ab7886c21561de71592ad122766"></a>
template&lt;typename M &gt; </td></tr>
<tr class="memitem:a839e9ab7886c21561de71592ad122766"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gap_char</b> ()</td></tr>
<tr class="separator:a839e9ab7886c21561de71592ad122766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97025b479338b5f418defaeded9c0d"><td class="memItemLeft" align="right" valign="top"><a id="a2f97025b479338b5f418defaeded9c0d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2f97025b479338b5f418defaeded9c0d"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gap_char&lt; Cdn &gt;</b> ()</td></tr>
<tr class="separator:a2f97025b479338b5f418defaeded9c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0b58ab62c4c2367f0dd3837b01b2a7"><td class="memTemplParams" colspan="2"><a id="abb0b58ab62c4c2367f0dd3837b01b2a7"></a>
template&lt;typename M &gt; </td></tr>
<tr class="memitem:abb0b58ab62c4c2367f0dd3837b01b2a7"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ins_char</b> (const M &amp;m)</td></tr>
<tr class="separator:abb0b58ab62c4c2367f0dd3837b01b2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac18c00ae264803387cd072c326e8ce"><td class="memItemLeft" align="right" valign="top"><a id="a2ac18c00ae264803387cd072c326e8ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2ac18c00ae264803387cd072c326e8ce"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ins_char&lt; Cdn &gt;</b> (const <a class="el" href="classbio_1_1_cdn.html">Cdn</a> &amp;c)</td></tr>
<tr class="separator:a2ac18c00ae264803387cd072c326e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace79b98466fef805ca2dd2c5648a4e00"><td class="memTemplParams" colspan="2"><a id="ace79b98466fef805ca2dd2c5648a4e00"></a>
template&lt;typename M &gt; </td></tr>
<tr class="memitem:ace79b98466fef805ca2dd2c5648a4e00"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reg_char</b> (const M &amp;m)</td></tr>
<tr class="separator:ace79b98466fef805ca2dd2c5648a4e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50710900bf704793d6f8d9ddac577f36"><td class="memItemLeft" align="right" valign="top"><a id="a50710900bf704793d6f8d9ddac577f36"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a50710900bf704793d6f8d9ddac577f36"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reg_char&lt; Cdn &gt;</b> (const <a class="el" href="classbio_1_1_cdn.html">Cdn</a> &amp;c)</td></tr>
<tr class="separator:a50710900bf704793d6f8d9ddac577f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3923fc2080993dc2c5eb1ebc84e412bb"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a3923fc2080993dc2c5eb1ebc84e412bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#a3923fc2080993dc2c5eb1ebc84e412bb">nw_align</a> (typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator q_lo, typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator q_hi, typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator t_lo, typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator t_hi, const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;match, int32_t gapp, <a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;result, bool score_only=false)</td></tr>
<tr class="separator:a3923fc2080993dc2c5eb1ebc84e412bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa7d6ed0b7776910e87c21357c4726"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a6faa7d6ed0b7776910e87c21357c4726"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#a6faa7d6ed0b7776910e87c21357c4726">nw_align</a> (const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;q, const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;t, const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;match, int32_t gapp, <a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;result, bool score_only=false)</td></tr>
<tr class="separator:a6faa7d6ed0b7776910e87c21357c4726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823438069edf731cc09b4ca945e8d82e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a823438069edf731cc09b4ca945e8d82e"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#a823438069edf731cc09b4ca945e8d82e">nw_self_align_score</a> (const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;query, const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;matrix)</td></tr>
<tr class="separator:a823438069edf731cc09b4ca945e8d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1cebb6b3a36e2e405599d3b834e6e8"><td class="memItemLeft" align="right" valign="top"><a id="a2e1cebb6b3a36e2e405599d3b834e6e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mm256_pack_cdns</b> (char *dst, const char *src, size_t len)</td></tr>
<tr class="separator:a2e1cebb6b3a36e2e405599d3b834e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fad4674429174cd43ed6b505840561d"><td class="memItemLeft" align="right" valign="top"><a id="a8fad4674429174cd43ed6b505840561d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mm256_complement_dna</b> (char *dna, size_t len)</td></tr>
<tr class="separator:a8fad4674429174cd43ed6b505840561d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506a7c88f3f4b6f84f15aaaedbffe926"><td class="memItemLeft" align="right" valign="top"><a id="a506a7c88f3f4b6f84f15aaaedbffe926"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mm256_reverse_complement_dna</b> (char *dna, size_t len)</td></tr>
<tr class="separator:a506a7c88f3f4b6f84f15aaaedbffe926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53947fd33046151b2a2fff9d0f6b6b9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#ac53947fd33046151b2a2fff9d0f6b6b9">next_lines</a> (const char *cur, size_t n, const char *end)</td></tr>
<tr class="separator:ac53947fd33046151b2a2fff9d0f6b6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1d6b260b0d829aaaed7479afaa79b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a4e1d6b260b0d829aaaed7479afaa79b8">seek_next</a> (const char *cur, const char *begin, const char *end)</td></tr>
<tr class="separator:a4e1d6b260b0d829aaaed7479afaa79b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b46699fd40314eed1cb0438d7af274"><td class="memItemLeft" align="right" valign="top"><a id="a91b46699fd40314eed1cb0438d7af274"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vector_accumulate</b> (std::vector&lt; unsigned &gt; &amp;a, const std::vector&lt; unsigned &gt; &amp;b)</td></tr>
<tr class="separator:a91b46699fd40314eed1cb0438d7af274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccdd204ee942d70036ee8e931d652d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#aeccdd204ee942d70036ee8e931d652d6">extract_read_data</a> (const <a class="el" href="structbio_1_1_const_mapping.html">ConstMapping</a> &amp;mapping)</td></tr>
<tr class="separator:aeccdd204ee942d70036ee8e931d652d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723115fb8888001373a263bcbc29d087"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_read_pair.html">ReadPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a723115fb8888001373a263bcbc29d087">qc_reads</a> (std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;fw, std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;rv, const std::vector&lt; <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> &gt; &amp;fwexs, const std::vector&lt; <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> &gt; &amp;rvexs, const <a class="el" href="structhelp_1_1_params.html">Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log)</td></tr>
<tr class="separator:a723115fb8888001373a263bcbc29d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4da41976a04bbacca86e804bb4515d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a1e4da41976a04bbacca86e804bb4515d">assemble_reads</a> (std::vector&lt; <a class="el" href="structbio_1_1_read_pair.html">ReadPair</a> &gt; &amp;&amp;pairs, const <a class="el" href="structhelp_1_1_params.html">Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log)</td></tr>
<tr class="separator:a1e4da41976a04bbacca86e804bb4515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f449c8e54459c6b4b634115e68db1e"><td class="memItemLeft" align="right" valign="top"><a id="af3f449c8e54459c6b4b634115e68db1e"></a>
std::array&lt; <a class="el" href="structbio_1_1_choice.html">Choice</a>, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_default_choices</b> ()</td></tr>
<tr class="separator:af3f449c8e54459c6b4b634115e68db1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267efc539a7edf43c2554155f4fe213a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a267efc539a7edf43c2554155f4fe213a">build_consensus_sequence</a> (std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;reads, const <a class="el" href="structhelp_1_1_params.html">Params</a> &amp;params, bool ragged_ends)</td></tr>
<tr class="separator:a267efc539a7edf43c2554155f4fe213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe66e23d5d64d50f345e80abebc9f90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a8fe66e23d5d64d50f345e80abebc9f90">umi_collapse</a> (std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;reads, const <a class="el" href="structhelp_1_1_params.html">Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log, bool ragged_ends)</td></tr>
<tr class="separator:a8fe66e23d5d64d50f345e80abebc9f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98e5062f2be919bbc5fe336f0e54c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a7e98e5062f2be919bbc5fe336f0e54c2">translate_and_filter_ptcs</a> (std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;preads, const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;p, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log, bool reverse_complement)</td></tr>
<tr class="separator:a7e98e5062f2be919bbc5fe336f0e54c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80529488aef3f9dbb7b16e7555cf1caf"><td class="memItemLeft" align="right" valign="top"><a id="a80529488aef3f9dbb7b16e7555cf1caf"></a>
std::vector&lt; <a class="el" href="structbio_1_1_group_alignment.html">GroupAlignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align_to_multiple_templates</b> (vecvec&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; &amp;&amp;orfs, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classbio_1_1_template_database.html">TemplateDatabase</a> &gt;&gt; &amp;dbs, const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log, bool ragged_ends)</td></tr>
<tr class="separator:a80529488aef3f9dbb7b16e7555cf1caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf03f3105c207ee90ef49510ea7092ea"><td class="memItemLeft" align="right" valign="top">vecvec&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#adf03f3105c207ee90ef49510ea7092ea">split_orfs</a> (std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; &amp;&amp;orfs, const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log)</td></tr>
<tr class="separator:adf03f3105c207ee90ef49510ea7092ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc36a625658b3329a80ddfa74c76ddb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbio_1_1_group_alignment.html">GroupAlignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a3bc36a625658b3329a80ddfa74c76ddb">align_to_template</a> (std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; &amp;&amp;orfs, const std::vector&lt; <a class="el" href="structbio_1_1_alignment_template.html">AlignmentTemplate</a> &gt; &amp;templates, const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log, bool ragged_ends)</td></tr>
<tr class="separator:a3bc36a625658b3329a80ddfa74c76ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c53eb412d8641e1392f195391cc835"><td class="memItemLeft" align="right" valign="top">vecvec&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#af1c53eb412d8641e1392f195391cc835">assign_templates</a> (std::vector&lt; std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt;&gt; &amp;&amp;orfs, std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classbio_1_1_template_database.html">TemplateDatabase</a> &gt;&gt; &amp;dbs, const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;params, <a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;log)</td></tr>
<tr class="separator:af1c53eb412d8641e1392f195391cc835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33786eca34ba0f0d41eef493a17649ad"><td class="memTemplParams" colspan="2"><a id="a33786eca34ba0f0d41eef493a17649ad"></a>
template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a33786eca34ba0f0d41eef493a17649ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>modal_element</b> (InputIt first, InputIt last) -&gt; InputIt</td></tr>
<tr class="separator:a33786eca34ba0f0d41eef493a17649ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69950c70ac9833e846bf4a53e041a602"><td class="memTemplParams" colspan="2"><a id="a69950c70ac9833e846bf4a53e041a602"></a>
template&lt;typename InputIt , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a69950c70ac9833e846bf4a53e041a602"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_for_each</b> (InputIt first, InputIt last, UnaryFunction f)</td></tr>
<tr class="separator:a69950c70ac9833e846bf4a53e041a602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24961d5a341e5a63ed743892cf1f969"><td class="memTemplParams" colspan="2"><a id="ad24961d5a341e5a63ed743892cf1f969"></a>
template&lt;typename InputIt , typename OutputIt , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ad24961d5a341e5a63ed743892cf1f969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_transform</b> (InputIt first, InputIt last, OutputIt out, UnaryOperation unary_op)</td></tr>
<tr class="separator:ad24961d5a341e5a63ed743892cf1f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4490c4c3e7acaadeb6ad9f97ce27150"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename TransformFilter , typename Log &gt; </td></tr>
<tr class="memitem:ac4490c4c3e7acaadeb6ad9f97ce27150"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#ac4490c4c3e7acaadeb6ad9f97ce27150">parallel_transform_filter</a> (InputIt first, InputIt last, OutputIt out, TransformFilter tf, Log &amp;log)</td></tr>
<tr class="separator:ac4490c4c3e7acaadeb6ad9f97ce27150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfd30cb1e9311b1a7336317ca4bd599"><td class="memTemplParams" colspan="2"><a id="a0cfd30cb1e9311b1a7336317ca4bd599"></a>
template&lt;typename InputIt , typename OutputIt , typename TransformFilterLog &gt; </td></tr>
<tr class="memitem:a0cfd30cb1e9311b1a7336317ca4bd599"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_transform_filter</b> (InputIt first, InputIt last, OutputIt out, TransformFilterLog &amp;tfl)</td></tr>
<tr class="separator:a0cfd30cb1e9311b1a7336317ca4bd599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a098b43dfdc2f406fcb36081bc13a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Reduce &gt; </td></tr>
<tr class="memitem:aa03a098b43dfdc2f406fcb36081bc13a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#aa03a098b43dfdc2f406fcb36081bc13a">parallel_reduce</a> (InputIt first, InputIt last, Reduce f) -&gt; decltype(f(first, last))</td></tr>
<tr class="separator:aa03a098b43dfdc2f406fcb36081bc13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89a63cd4e84e666b364d8acf412111"><td class="memItemLeft" align="right" valign="top"><a id="a7f89a63cd4e84e666b364d8acf412111"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classbio_1_1_polymer_base.html">PolymerBase</a> &amp;p)</td></tr>
<tr class="separator:a7f89a63cd4e84e666b364d8acf412111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f10ff6a0507fb1a6197c6baa37e3e1"><td class="memItemLeft" align="right" valign="top"><a id="af6f10ff6a0507fb1a6197c6baa37e3e1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getline</b> (const char *begin, const char *end, std::string &amp;s)</td></tr>
<tr class="separator:af6f10ff6a0507fb1a6197c6baa37e3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb92a4740d0377a7b31b9fc3dbdfb34"><td class="memItemLeft" align="right" valign="top"><a id="a5cb92a4740d0377a7b31b9fc3dbdfb34"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>skipline</b> (const char *begin, const char *end, char delim)</td></tr>
<tr class="separator:a5cb92a4740d0377a7b31b9fc3dbdfb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b3fb8b9736a59c703dd3e89f10b0e7"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebio.html#a28b3fb8b9736a59c703dd3e89f10b0e7">skipline</a> (std::istream &amp;is)</td></tr>
<tr class="separator:a28b3fb8b9736a59c703dd3e89f10b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c344056c6141ba8fd2ef3cb1cb9ad4"><td class="memTemplParams" colspan="2">template&lt;typename Monomer &gt; </td></tr>
<tr class="memitem:a71c344056c6141ba8fd2ef3cb1cb9ad4"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebio.html#a71c344056c6141ba8fd2ef3cb1cb9ad4">getline</a> (std::istream &amp;is, <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; Monomer &gt; &amp;p, size_t &amp;stripped)</td></tr>
<tr class="separator:a71c344056c6141ba8fd2ef3cb1cb9ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab372105d656fea9adc9c5299da6c5d2b"><td class="memTemplParams" colspan="2"><a id="ab372105d656fea9adc9c5299da6c5d2b"></a>
template&lt;typename Monomer &gt; </td></tr>
<tr class="memitem:ab372105d656fea9adc9c5299da6c5d2b"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getline</b> (const char *begin, const char *end, <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; Monomer &gt; &amp;p, size_t &amp;stripped)</td></tr>
<tr class="separator:ab372105d656fea9adc9c5299da6c5d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a965930aacfadc5a1f1edce09e57b6047"><td class="memItemLeft" align="right" valign="top"><a id="a965930aacfadc5a1f1edce09e57b6047"></a>
const <a class="el" href="classbio_1_1_translation_table.html">TranslationTable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StandardTranslationTable</b> (<a class="el" href="classbio_1_1_aas.html">Aas</a>(&quot;KNNKTTTTIIIMRSSRQHHQPPPPLLLLRRRR*YY*SSSSLFFL*CCWEDDEAAAAVVVVGGGG&quot;))</td></tr>
<tr class="separator:a965930aacfadc5a1f1edce09e57b6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6458ccf237a7fd1e6ef8595af016d023"><td class="memItemLeft" align="right" valign="top"><a id="a6458ccf237a7fd1e6ef8595af016d023"></a>
const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BLOSUM62</b> (21, 21, blosum62_data)</td></tr>
<tr class="separator:a6458ccf237a7fd1e6ef8595af016d023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5c5eedf972d8ab9cb1b5d07848fb84"><td class="memItemLeft" align="right" valign="top"><a id="afa5c5eedf972d8ab9cb1b5d07848fb84"></a>
const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NTSUBS</b> (4, 4, { 1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 1})</td></tr>
<tr class="separator:afa5c5eedf972d8ab9cb1b5d07848fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a0ced4db281e69a707e43b85def1c"><td class="memItemLeft" align="right" valign="top"><a id="a410a0ced4db281e69a707e43b85def1c"></a>
const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CDNSUBS</b> (64, 64, cdnsubs_data)</td></tr>
<tr class="separator:a410a0ced4db281e69a707e43b85def1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Multithreaded implementations of some algorithms. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa4b9619f0755538ec0031e3d782084dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b9619f0755538ec0031e3d782084dc">&#9670;&nbsp;</a></span>MappingStage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacebio.html#aa4b9619f0755538ec0031e3d782084dc">bio::MappingStage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The stage of the file mapping process where an exception occurred. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3bc36a625658b3329a80ddfa74c76ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc36a625658b3329a80ddfa74c76ddb">&#9670;&nbsp;</a></span>align_to_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structbio_1_1_group_alignment.html">GroupAlignment</a>&gt; bio::align_to_template </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structbio_1_1_alignment_template.html">AlignmentTemplate</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>templates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ragged_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align ORFs to an amino acid template.</p>
<p>Output is a gapped string of ASCII amino acids.</p>
<p>Low scoring alignments (those scoring below params.min_alignment_score) will be filtered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orfs</td><td>the ORFs to align to the template params.aa_template </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of ORFs containing stop codons</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alignments that pass QC </dd></dl>

</div>
</div>
<a id="a1e4da41976a04bbacca86e804bb4515d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4da41976a04bbacca86e804bb4515d">&#9670;&nbsp;</a></span>assemble_reads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; bio::assemble_reads </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read_pair.html">ReadPair</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble paired-end reads.</p>
<p>Will assemble reads by aligning the 3' ends of the fw read and the reverse complement of the rv read. Requires a minimum number of overlapping bases (params.min_overlap) but permits some number of mismatces (params.max_mismatches) within the region of overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>the unpaired reads </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of reads that to align</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pairs of reads (not yet assembled) for which assembly was successful </dd></dl>

</div>
</div>
<a id="af1c53eb412d8641e1392f195391cc835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c53eb412d8641e1392f195391cc835">&#9670;&nbsp;</a></span>assign_templates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vecvec&lt;<a class="el" href="structbio_1_1_orf.html">Orf</a>&gt; bio::assign_templates </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classbio_1_1_template_database.html">TemplateDatabase</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the template_id of each <a class="el" href="structbio_1_1_orf.html">Orf</a> to the index of the closest template in the corresponding database.</p>
<p>Note, this function assumes split Orfs and multiple template databases. For example, orfs[i][1] will be matched against the templates in dbs[1] and orfs[j][2] will be matched against the templates in dbs[2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orfs</td><td>2D array of <a class="el" href="structbio_1_1_orf.html">Orf</a>; 2nd dimension must be dbs.size() </td></tr>
    <tr><td class="paramname">dbs</td><td>the template databases </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of ORFs where no matching template could be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D array of <a class="el" href="structbio_1_1_orf.html">Orf</a> with template ids assigned, less any where template could not be matched </dd></dl>

</div>
</div>
<a id="a267efc539a7edf43c2554155f4fe213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267efc539a7edf43c2554155f4fe213a">&#9670;&nbsp;</a></span>build_consensus_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bio::build_consensus_sequence </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ragged_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ragged_ends means sequences are expected to be the same length, any indels</p>

</div>
</div>
<a id="aeccdd204ee942d70036ee8e931d652d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccdd204ee942d70036ee8e931d652d6">&#9670;&nbsp;</a></span>extract_read_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; bio::extract_read_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbio_1_1_const_mapping.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a memory mapped .fastq file.</p>
<p>Reads will be filtered if the contain non ATGC characters (i.e. Ns) or if there is a mismatch between the sequence length and the fastq quality length.</p>
<p>@params mapping a memory mapped fastq file </p><dl class="section return"><dt>Returns</dt><dd>the unpaired reads and quality data </dd></dl>

</div>
</div>
<a id="a6320a1508e48d50d15a6e7777014fdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320a1508e48d50d15a6e7777014fdfa">&#9670;&nbsp;</a></span>find_overlapv_256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbio_1_1_overlap.html">Overlap</a> bio::find_overlapv_256 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>b_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_mismatches</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the length of the longest suffix of a that is also a prefix of b</p>
<p>Vectorized implementation using AVX instructions. Tolerates some number of mismatches in the alignment although for most uses max_mismatches should be left at 0 (the default).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>sequence a </td></tr>
    <tr><td class="paramname">a_size</td><td>number of symbols in a </td></tr>
    <tr><td class="paramname">b</td><td>sequence b </td></tr>
    <tr><td class="paramname">b_size</td><td>number of symbols in b </td></tr>
    <tr><td class="paramname">max_mismatches</td><td>maximum permissible mismatces in overlap region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structbio_1_1_overlap.html">Overlap</a> object containing length of the longest overlapping region and number of mismatches in that region. </dd></dl>

</div>
</div>
<a id="a71c344056c6141ba8fd2ef3cb1cb9ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c344056c6141ba8fd2ef3cb1cb9ad4">&#9670;&nbsp;</a></span>getline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Monomer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; bio::getline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; Monomer &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>stripped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implement getline for polymer types that handles <br  />
, \r, and \r<br  />
 newlines. Thanks to Stackoverflow queston #6089231! </p>

</div>
</div>
<a id="ac53947fd33046151b2a2fff9d0f6b6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53947fd33046151b2a2fff9d0f6b6b9">&#9670;&nbsp;</a></span>next_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * bio::next_lines </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance pointer into buffered file over given number of newlines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>the starting pointer in the buffer. </td></tr>
    <tr><td class="paramname">n</td><td>the number of newlines to skip. </td></tr>
    <tr><td class="paramname">end</td><td>pointer to last+1 character of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the character after the nth newline, or end if end of buffer reached first. </dd></dl>

</div>
</div>
<a id="a6faa7d6ed0b7776910e87c21357c4726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6faa7d6ed0b7776910e87c21357c4726">&#9670;&nbsp;</a></span>nw_align() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bio::nw_align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>gapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic implementation of Needleman-Wunsch for Polymers of monomer type M.</p>
<p>Takes a user-supplied match score matrix and gap penalty. Results are stored in the pass-by-reference <a class="el" href="structbio_1_1_alignment.html">Alignment</a> structure. The substitution matrix should be 4x4 with rows and columns corresponding to the values of Nt::index().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>the type of monomer (<a class="el" href="classbio_1_1_aa.html">Aa</a>, <a class="el" href="classbio_1_1_nt.html">Nt</a>, etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the amino acid "query" sequence </td></tr>
    <tr><td class="paramname">templ</td><td>the amino acid "template" sequence </td></tr>
    <tr><td class="paramname">substitution_matrix</td><td>the substituion scoring matrix (e.g. BLOSUM62 for M=<a class="el" href="classbio_1_1_aa.html">Aa</a>) </td></tr>
    <tr><td class="paramname">gapp</td><td>the gap penalty </td></tr>
    <tr><td class="paramname">result</td><td>stores the results of the alignment as a string </td></tr>
    <tr><td class="paramname">score_only</td><td>if set to true, only the alignment score will be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3923fc2080993dc2c5eb1ebc84e412bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3923fc2080993dc2c5eb1ebc84e412bb">&#9670;&nbsp;</a></span>nw_align() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bio::nw_align </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>q_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>q_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>t_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>t_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>gapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic implementation of Needleman-Wunsch for Polymers of monomer type M.</p>
<p>Takes a user-supplied match score matrix and gap penalty. Results are stored in the pass-by-reference <a class="el" href="structbio_1_1_alignment.html">Alignment</a> structure. The substitution matrix should be 4x4 with rows and columns corresponding to the values of Nt::index().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>the type of monomer (<a class="el" href="classbio_1_1_aa.html">Aa</a>, <a class="el" href="classbio_1_1_nt.html">Nt</a>, etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_lo</td><td>the first monomer in the "query" sequence </td></tr>
    <tr><td class="paramname">q_hi</td><td>the last + 1 monomer in the "query" sequence </td></tr>
    <tr><td class="paramname">t_lo</td><td>the first monomer in the "template" sequence </td></tr>
    <tr><td class="paramname">t_hi</td><td>the last + 1 monomer in the "template" sequence </td></tr>
    <tr><td class="paramname">templ</td><td>the amino acid "template" sequence </td></tr>
    <tr><td class="paramname">substitution_matrix</td><td>the substituion scoring matrix (e.g. BLOSUM62 for M=<a class="el" href="classbio_1_1_aa.html">Aa</a>) </td></tr>
    <tr><td class="paramname">gapp</td><td>the gap penalty </td></tr>
    <tr><td class="paramname">result</td><td>stores the results of the alignment as a string </td></tr>
    <tr><td class="paramname">score_only</td><td>if set to true, only the alignment score will be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80fbb3af7886f1eaafce331cc9303e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fbb3af7886f1eaafce331cc9303e8a">&#9670;&nbsp;</a></span>nw_align_aas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bio::nw_align_aas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_aas.html">Aas</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_aas.html">Aas</a> &amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>substitution_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>gapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of Needleman-Wunsch for amino acid sequences.</p>
<p>Takes a user-supplied match score matrix and gap penalty. Results are stored in the pass-by-reference <a class="el" href="structbio_1_1_alignment.html">Alignment</a> structure. The substitution matrix should be 21x21 with rows and columns corresponding to the values of <a class="el" href="classbio_1_1_aa.html#a9d3201a952c06e455054eb328203e812">Aa::index()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the amino acid "query" sequence </td></tr>
    <tr><td class="paramname">templ</td><td>the amino acid "template" sequence </td></tr>
    <tr><td class="paramname">substitution_matrix</td><td>the substituion scoring matrix (e.g. BLOSUM62) </td></tr>
    <tr><td class="paramname">gapp</td><td>the gap extension penalty </td></tr>
    <tr><td class="paramname">result</td><td>stores the results of the alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a823438069edf731cc09b4ca945e8d82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823438069edf731cc09b4ca945e8d82e">&#9670;&nbsp;</a></span>nw_self_align_score()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t bio::nw_self_align_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_polymer.html">Polymer</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbio_1_1_matrix.html">Matrix</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Needleman-Wunsch score for aligning a sequence to itself. </p>

</div>
</div>
<a id="ab3b5fd66bcb5118522e4f23f2e400daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b5fd66bcb5118522e4f23f2e400daa">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; bio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbio_1_1_read.html">Read</a> &amp;&#160;</td>
          <td class="paramname"><em>rd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a read for debugging purposes </p>

</div>
</div>
<a id="aa03a098b43dfdc2f406fcb36081bc13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03a098b43dfdc2f406fcb36081bc13a">&#9670;&nbsp;</a></span>parallel_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Reduce &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bio::parallel_reduce </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduce&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(first, last)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multithreaded reduction over [first, last) using binary function Reduces </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>the input iterator type </td></tr>
    <tr><td class="paramname">Reduce</td><td>a binary function that operates on two <em>iterators</em> representing a range of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first iterator in the range </td></tr>
    <tr><td class="paramname">last</td><td>the one-past-the end iterator in the range </td></tr>
    <tr><td class="paramname">f</td><td>a callable (funnctor, lambda, etc.) that takes two InputIt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return type of f </dd></dl>

</div>
</div>
<a id="ac4490c4c3e7acaadeb6ad9f97ce27150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4490c4c3e7acaadeb6ad9f97ce27150">&#9670;&nbsp;</a></span>parallel_transform_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename TransformFilter , typename Log &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIt bio::parallel_transform_filter </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformFilter&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Log &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multithreaded transform over [first, last) using binary functor TransformFilter TransformFilter should return std::optional&lt;T&gt; where T is the desired output type std::nullopt outputs from TransformFilter are discarded</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>the input iterator type </td></tr>
    <tr><td class="paramname">OutputIt</td><td>the output iterator type (threads std::copy their results here) </td></tr>
    <tr><td class="paramname">TransformFilter</td><td>a functor that takes InputIt::value_type and Log and returns std::optional&lt;OutputIt::value_type&gt; </td></tr>
    <tr><td class="paramname">Log</td><td>a structure to capture error information, must define operator + for use in std::accumulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first iterator in the range </td></tr>
    <tr><td class="paramname">last</td><td>the one-past-the end iterator in the range </td></tr>
    <tr><td class="paramname">out</td><td>the destination for results </td></tr>
    <tr><td class="paramname">tf</td><td>callable that takes InputIt::value_type and a Log instance, returns std::optional&lt;OutputIt::value_type&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OutputIt out after recieving transformed values </dd></dl>

</div>
</div>
<a id="a723115fb8888001373a263bcbc29d087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723115fb8888001373a263bcbc29d087">&#9670;&nbsp;</a></span>qc_reads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structbio_1_1_read_pair.html">ReadPair</a> &gt; bio::qc_reads </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fwexs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rvexs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove poor quality sequeces from data.</p>
<p>Bases at 3' read ends are removed if they fall below params.tq_qual_min. The reference sequence itself will be trimmed from the read and the UMI barcode extracted. Reads fail QC if the fw or rv reference sequence/UMI cannot be identified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw</td><td>the unpaired forward reads </td></tr>
    <tr><td class="paramname">rv</td><td>the unpaired reverse reads </td></tr>
    <tr><td class="paramname">fwex</td><td>a <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> initialized with the forawrd reference sequence </td></tr>
    <tr><td class="paramname">rvex</td><td>a <a class="el" href="classbio_1_1_u_m_i_extractor.html">UMIExtractor</a> initialized with the reverse reference sequence </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of reads that fail QC for one reason or another</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pairs of reads (not yet assembled) for which both fw and rv passed QC </dd></dl>

</div>
</div>
<a id="a4e1d6b260b0d829aaaed7479afaa79b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1d6b260b0d829aaaed7479afaa79b8">&#9670;&nbsp;</a></span>seek_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * bio::seek_next </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance arbitrary pointer into buffered fastq file to start of next record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>the starting pointer in the buffer. </td></tr>
    <tr><td class="paramname">begin</td><td>pointer to first character in buffer. </td></tr>
    <tr><td class="paramname">end</td><td>pointer to last+1 character of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first character of the next record, or end if end of buffer reached first. </dd></dl>

</div>
</div>
<a id="a28b3fb8b9736a59c703dd3e89f10b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b3fb8b9736a59c703dd3e89f10b0e7">&#9670;&nbsp;</a></span>skipline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; bio::skipline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ignore a line entirely. </p>

</div>
</div>
<a id="adf03f3105c207ee90ef49510ea7092ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf03f3105c207ee90ef49510ea7092ea">&#9670;&nbsp;</a></span>split_orfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vecvec&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; bio::split_orfs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split ORFs according to params.split_template_regex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orfs</td><td>the orfs to split </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of ORFs that could not be split</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of vector of <a class="el" href="structbio_1_1_orf.html">Orf</a> where each element of the inner vectors is one of the split orfs </dd></dl>

</div>
</div>
<a id="a7e98e5062f2be919bbc5fe336f0e54c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e98e5062f2be919bbc5fe336f0e54c2">&#9670;&nbsp;</a></span>translate_and_filter_ptcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structbio_1_1_orf.html">Orf</a> &gt; bio::translate_and_filter_ptcs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate ORFs from nucleotide data.</p>
<p>Reads should be in frame such that the first nucleotide of a forward read is the first nucleotide of the first codon in the ORF. The first nucleotide of a reverse read should be the last nucleotide of the last codon in the ORF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reads</td><td>the nucleotide read data (paired or unpaired) </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of ORFs containing stop codons </td></tr>
    <tr><td class="paramname">reverse_complement</td><td>set true to translate the reverse complement strand (i.e. for reverse reads)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ORFs without stop codons </dd></dl>

</div>
</div>
<a id="a8fe66e23d5d64d50f345e80abebc9f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe66e23d5d64d50f345e80abebc9f90">&#9670;&nbsp;</a></span>umi_collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; bio::umi_collapse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structbio_1_1_read.html">Read</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelp_1_1_params.html">help::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ragged_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a conensus nucleotide sequence from a group of reads.</p>
<p>Two means of building the consensus are available based on whether or not all reads are expected to be the same length (paired reads) or different lengths varying in their 3' tails (unpaired reads). The ragged_ends flag should be set to false for paired reads or true for unpaired reads. <br  />
 UMI groups with fewer than params.min_umi_group_size members will be discarded. <br  />
 For unpaired reads a consensus will be created with length such that a the consensus nucleotide at any given position represents at least params.min_umi_group_size sequences. <br  />
 For paired reads, the consensus sequence length will be the modal length of the sequences in the group. <br  />
 For each position in the consensus, the consensus nucleotide will be the modal nucleotide at that position in the inputs. If there is no single mode (e.g. for a group of two inputs), fastq quality will be used to break the tie.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reads</td><td>the reads, paired or unpaired </td></tr>
    <tr><td class="paramname">params</td><td>run options from command line arguments </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="structbio_1_1_parse_log.html">ParseLog</a> to store counts of reads "collapsed" </td></tr>
    <tr><td class="paramname">ragged_ends</td><td>set true when reads are expected to vary in length (i.e. unpaired reads)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the consensus sequences for each UMI group </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
